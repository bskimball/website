---
title: 'TanStack Hono - A SSR Monolith with Tanstack Router and Hono'
pubDate: '2025-9-20'
tags: ['typescript', 'development', 'reactjs']
draft: false
description: 'A SSR monolith web framework for TypeScript and JavaScript, built on top of the Hono framework and Tanstack Router.'
heroImage: /static/images/tanstack-hono.png
---

Preface:

I've been using TanStack Router and Hono for a while and appreciate how well their philosophies align: TanStack Router gives you a strongly typed, data‑aware routing core; Hono provides a tiny, fast, standards‑leaning HTTP layer that runs comfortably on Node or edge platforms.

This project explores combining them into a single SSR + CSR monolith for TypeScript: one process (in dev) that can server‑render React routes, hydrate on the client, and expose lightweight API/RPC endpoints without jumping to a heavier meta‑framework.

Rather than serving the router purely as an SPA (what I had previously done) or using Hono/JSX, I adapted the official TanStack Router SSR example—swapping Express for Hono and layering in a typed API example to illustrate a simple RPC style.

Repo: [github.com/bskimball/tanstack-hono](https://github.com/bskimball/tanstack-hono)

Development uses the Hono dev server with Vite powering both the client bundle and the server entry, so hot reloading applies across routes, server handlers, and shared types.

---

## Why a "Monolith"?

Monolith here simply means: one repository + one runtime process (in dev) that handles:

- HTTP routing (API + SSR HTML responses)
- React server rendering + hydration delivery
- Static asset compilation (Vite)
- Type‑safe internal RPC style endpoints

The goal is to keep operational complexity low while still enabling progressive enhancement and dynamic UI.

---

## Architecture Overview

High level flow:

1. Request enters Hono.
2. Path is checked against API / RPC routes (e.g. `/api/todos`). If matched: handler runs, JSON returned.
3. Otherwise SSR handler:
	 - Creates a TanStack Router instance with the route tree
	 - Resolves the matching route elements (no framework‑specific loader layer)
	 - Renders React to string / stream
	 - Injects serialized router state + asset tags
4. Client hydrates the router instance; subsequent navigation is client‑side.

This pattern mirrors the official TanStack Router SSR example, replacing Express with Hono and integrating its middleware ergonomics + performance.

---

## File / Responsibility Layout (Conceptual)

```
src/           # createRouter(), renderToString(), HTML template
  	components/   # Shared React components
    	Header.tsx      # Example shared header
	routes/
		__root.tsx         # Root route with layout + <Outlet />
		index.tsx          # / home route
		about.tsx          # /about
		todos/
			index.tsx        # /todos list
			$id.tsx          # /todos/:id detail
	api/
		todos.ts           # Example Hono route or RPC style handler
	shared/
		types.ts           # Shared Zod / TS types for API + UI
	entry-client.tsx   # Hydration entry
	entry-server.tsx   # Server render entry (invoked by ssr.ts)
```

## RPC / Type Safety Options

Options for client ↔ server data flow inside this monolith:

- Plain REST style Hono handlers (`/api/...`)
- Zod validated request/response contracts shared between `api/` and `routes/`
- A thin wrapper that maps a function name to a POST body (DIY tRPC‑lite)
- Or adopt a full RPC layer (e.g. tRPC) if you want code‑gen inference—Hono integrates fine via adapters

Early on I prefer the middle option: explicit Hono endpoints + Zod schemas for a minimal dependency footprint.

---

## Vite Integration

Using the Hono dev server means Vite is already compiling the React code. For SSR you typically:

1. Create a Vite build with `manifest.json` enabled for production.
2. Read the manifest in SSR code to inject hashed asset URLs.
3. In dev, rely on the Vite dev server middleware (or Hono adapter) for on‑the‑fly transforms.

Key benefits:

- Fast HMR for routes & components
- Single dependency graph; no duplicate bundlers
- Easier to reason about relative imports & aliasing

---

## Comparison: Express vs Hono for This Use Case

| Aspect | Express | Hono |
| ------ | ------- | ---- |
| Bundle size (edge) | Heavier | Very small |
| Middleware style | Classic, broad ecosystem | Modern, minimal, Web Standard flavored |
| TypeScript ergonomics | Manual typings | Built with TS, better generics |
| Edge/Workers deploy | Extra libs needed | First‑class (Cloudflare, etc.) |
| Performance | Good | Often faster in microbenchmarks |

For a lean SSR stack that might later target edge runtimes, Hono is a solid fit.

---

## Deployment Notes

You can push this monolith to several targets:

- Node server (traditional) – simplest path, run built server + static assets
- Cloudflare Workers / Pages – if avoiding Node APIs, ensure any Node‑only modules (fs, path) are gated or replaced
- Fly.io / Render / Railway – containerize, expose port

Production build considerations:

```bash
vite build --ssr src/server/entry-server.tsx
vite build               # client
```

Then serve with a small bootstrap that loads the SSR bundle, reads the client manifest, and instantiates the Hono app.

Edge runtime targets may need a streaming strategy using Web Streams instead of Node streams.
